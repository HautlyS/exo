name: Build Windows

on:
  push:
    tags: ["v*"]
  workflow_dispatch:
    inputs:
      version:
        description: "Version to build (e.g., v1.0.0)"
        required: true

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  build-windows:
    name: Build Windows ${{ matrix.arch }}
    runs-on: windows-latest
    strategy:
      fail-fast: false
      matrix:
        arch: [x86_64, arm64]

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup UV
        uses: astral-sh/setup-uv@v6
        with:
          enable-cache: true
          cache-dependency-glob: uv.lock

      - name: Setup Python
        run: uv python install 3.13

      - name: Setup Nix (Windows - using WSL2)
        uses: cachix/install-nix-action@v31
        with:
          nix_path: nixpkgs=channel:nixos-unstable
          extra_nix_config: |
            system-features = nixos-test benchmark big-parallel kvm

      - name: Configure Cachix
        uses: cachix/cachix-action@v14
        with:
          name: exo
          authToken: "${{ secrets.CACHIX_AUTH_TOKEN }}"

      - name: Determine version
        id: version
        shell: powershell
        run: |
          if ("${{ github.event_name }}" -eq "workflow_dispatch") {
            $version = "${{ github.event.inputs.version }}"
          } else {
            $version = "${{ github.ref }}".Replace("refs/tags/", "")
          }
          $version = $version.TrimStart("v")
          echo "version=$version" >> $env:GITHUB_OUTPUT
          Write-Host "Version: $version"

      - name: Build dashboard
        run: |
          nix build .#dashboard --print-build-logs --no-link --print-out-paths > build-out.txt
          $DASHBOARD_OUT = Get-Content build-out.txt
          New-Item -ItemType Directory -Path "dashboard/build" -Force
          Copy-Item "$DASHBOARD_OUT/*" -Destination "dashboard/build" -Recurse

      - name: Build Python bundle with PyInstaller
        run: |
          uv sync --locked
          uv run pyinstaller packaging/pyinstaller/exo.spec

      - name: Detect GPU drivers
        shell: python
        run: |
          import subprocess
          import json
          
          gpu_info = {
              "cuda": False,
              "rocm": False,
              "intel_arc": False,
              "cpu_only": True
          }
          
          # Check NVIDIA CUDA
          try:
              subprocess.run(["nvidia-smi"], check=True, capture_output=True)
              gpu_info["cuda"] = True
              gpu_info["cpu_only"] = False
          except FileNotFoundError:
              pass
          
          # Check AMD ROCm
          try:
              subprocess.run(["hipcc", "--version"], check=True, capture_output=True)
              gpu_info["rocm"] = True
              gpu_info["cpu_only"] = False
          except FileNotFoundError:
              pass
          
          # Check Intel Arc
          try:
              subprocess.run(["clinfo"], check=True, capture_output=True)
              gpu_info["intel_arc"] = True
              gpu_info["cpu_only"] = False
          except FileNotFoundError:
              pass
          
          with open("gpu-info.json", "w") as f:
              json.dump(gpu_info, f, indent=2)
          
          print("GPU Detection Results:")
          for key, value in gpu_info.items():
              print(f"  {key}: {value}")

      - name: Install NSIS
        run: |
          choco install nsis -y --no-progress

      - name: Build NSIS Installer
        shell: cmd
        run: |
          mkdir dist
          makensis /V4 /DVERSION=${{ steps.version.outputs.version }} ^
            /DPYINSTALLER_DIR=dist\exo ^
            packaging\windows\nsis\exo.nsi
          if exist "dist\EXO-${{ steps.version.outputs.version }}-setup.exe" (
            echo Created NSIS installer
          ) else (
            echo Warning: NSIS installer not created, creating fallback
            copy dist\exo dist\EXO-${{ steps.version.outputs.version }}-portable.zip
          )

      - name: Setup Visual Studio Build Tools (for WiX)
        run: |
          # Download and install WiX v3.x or v4.x
          # choco install wixtoolset -y --no-progress
          # For now, skip WiX as it requires specific tooling
          echo "WiX setup would happen here"

      - name: Create portable ZIP
        shell: powershell
        run: |
          $zipPath = "dist\EXO-${{ steps.version.outputs.version }}-portable-${{ matrix.arch }}.zip"
          Compress-Archive -Path "dist\exo\*" -DestinationPath $zipPath
          Write-Host "Created portable ZIP: $zipPath"

      - name: Generate checksums
        shell: powershell
        run: |
          cd dist
          $files = Get-ChildItem -File
          foreach ($file in $files) {
              $hash = (Get-FileHash -Path $file.FullName -Algorithm SHA256).Hash
              "$hash  $($file.Name)" | Add-Content -Path "SHA256SUMS"
          }
          $files = Get-ChildItem -File
          foreach ($file in $files) {
              $hash = (Get-FileHash -Path $file.FullName -Algorithm SHA512).Hash
              "$hash  $($file.Name)" | Add-Content -Path "SHA512SUMS"
          }

      - name: Sign executables (if code signing cert available)
        if: ${{ secrets.WINDOWS_CODE_SIGN_CERT != '' }}
        shell: powershell
        run: |
          # Import certificate
          $certPath = "temp_cert.pfx"
          $certPassword = ConvertTo-SecureString -String "${{ secrets.WINDOWS_CODE_SIGN_PASS }}" -AsPlainText -Force
          
          # Decode base64 certificate
          [System.Convert]::FromBase64String("${{ secrets.WINDOWS_CODE_SIGN_CERT }}") | Set-Content -Path $certPath -AsByteStream
          
          # Import to Windows certificate store
          Import-PfxCertificate -FilePath $certPath -CertStoreLocation "Cert:\CurrentUser\My" -Password $certPassword
          
          # Get the certificate thumbprint
          $cert = Get-ChildItem -Path Cert:\CurrentUser\My | Where-Object { $_.Issuer -like "*EV*" -or $_.Subject -like "*exo*" } | Select-Object -First 1
          if ($cert) {
              $thumbprint = $cert.Thumbprint
              
              # Sign all executables
              Get-ChildItem "dist\exo\*.exe" | ForEach-Object {
                  Write-Host "Signing: $_"
                  signtool.exe sign /f $certPath /p "${{ secrets.WINDOWS_CODE_SIGN_PASS }}" /t http://timestamp.comodoca.com/authenticode $_
              }
              
              Get-ChildItem "dist\*.exe" | ForEach-Object {
                  Write-Host "Signing: $_"
                  signtool.exe sign /f $certPath /p "${{ secrets.WINDOWS_CODE_SIGN_PASS }}" /t http://timestamp.comodoca.com/authenticode $_
              }
          } else {
              Write-Host "Warning: Code signing certificate not found"
          }
          
          Remove-Item $certPath

      - name: Verify signatures
        shell: powershell
        run: |
          Get-ChildItem "dist\*.exe", "dist\exo\*.exe" -ErrorAction SilentlyContinue | ForEach-Object {
              $sig = Get-AuthenticodeSignature $_
              Write-Host "File: $($_.Name)"
              Write-Host "  Status: $($sig.Status)"
              Write-Host "  Signer: $($sig.SignerCertificate.Subject)"
          }

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: exo-windows-${{ matrix.arch }}
          path: dist/
          retention-days: 7

      - name: Upload to S3 (if configured)
        if: ${{ secrets.AWS_S3_BUCKET != '' && startsWith(github.ref, 'refs/tags/') }}
        shell: powershell
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          AWS_REGION: us-east-1
          S3_BUCKET: ${{ secrets.AWS_S3_BUCKET }}
          S3_PREFIX: releases
        run: |
          $bucket = $env:S3_BUCKET
          $prefix = "${{ steps.version.outputs.version }}"
          
          Get-ChildItem "dist\*" -File | ForEach-Object {
              $file = $_.Name
              Write-Host "Uploading: $file"
              aws s3 cp $_.FullName "s3://$bucket/releases/$prefix/$file"
          }

  verify-builds:
    name: Verify all Windows builds
    needs: build-windows
    runs-on: ubuntu-latest
    if: always()

    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Verify artifacts
        run: |
          echo "=== Build Summary ==="
          find artifacts -type f -name "SHA256SUMS" -exec cat {} \;
          echo ""
          echo "=== Artifact Count ==="
          find artifacts -type f | wc -l
          echo ""
          echo "=== File Types ==="
          find artifacts -type f | sed 's/.*\.//' | sort | uniq -c

  publish-release:
    name: Publish to GitHub Release
    needs: [verify-builds]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')

    steps:
      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: artifacts/**/*
          generate_release_notes: true
          draft: false
          prerelease: ${{ contains(github.ref, 'alpha') || contains(github.ref, 'beta') }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
